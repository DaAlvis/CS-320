# CS-320
Reflecting on the work I completed in Projects One and Two has really helped me solidify my understanding of software testing, automation, and quality assurance. One of the main ways I can ensure that my code, program, or software is functional and secure is by creating comprehensive unit tests and leveraging test automation. For example, the ContactTest.java and ContactServiceTest.java files I wrote allowed me to check that all methods in my contact service behaved as expected. I also made sure that input validation was enforced and that exceptions were thrown when invalid data was used, which helps prevent security vulnerabilities such as incorrect data manipulation or crashes. Consistently reviewing code for edge cases and running automated tests gives me confidence that my software is reliable before release.

Interpreting user needs and incorporating them into a program starts with understanding the requirements thoroughly. In my projects, I focused on delivering the features requested by the client, including contact management, task management, and appointment scheduling. I paid attention to details like input constraints, data integrity, and usability to ensure that the software aligned with their expectations. I also considered potential errors that users might encounter and tested for those scenarios so that the program could handle them gracefully. This approach ensures that the software is not only functional but also meets the real-world needs of the end users.

When approaching software design, I focus on creating a clear structure and separating concerns. For the mobile application in Project One, I organized the code into services, models, and tests. This separation made it easier to implement unit tests and update individual components without affecting the rest of the application. I also followed principles like encapsulation and modularity, which helped make the code more maintainable and easier to expand in the future. Designing with testing in mind allowed me to identify potential defects early and reduce technical debt, which is a crucial part of producing quality software.

Overall, these projects taught me that functional, secure, and user-friendly software comes from careful planning, consistent testing, and thoughtful design. Documenting my processes in the portfolio and reflecting on them now will help me carry these practices into future projects and into my professional career.

